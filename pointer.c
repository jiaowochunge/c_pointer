#include <stdio.h>
 
void testfunc() {}
 
int main(void) {
	// your code goes here
	// 这个编码方式很奇怪，也是因为我对字节对齐一窍不通。这个buffer是为了避免缓冲区溢出，*(int *)(&tt + 1)将溢出到这里来
    // 这些数组的大小事经过安排的，都是4的倍数，一个int4字节，4个int刚好凑齐16个字节。为什么？因为我之前是10的倍数，然后由于我对字节对齐一窍不通，导致不好计算溢出后的位置。精心安排后，虽然我不懂字节对齐，也能计算位置
    int buffer[15] = {-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15};
    // 然而t不在buffer的地址之下，所以我说奇怪。不过没关系，只要我们把这个地址位置打印出来，还是可以解释下面的问题。
    int t = 9;
    int tt[8] = {1, 2, 3, 4, 5, 6, 7, 8};
    int ttt[2][4] = {11, 12, 13, 14, 21, 22, 23, 24};
    int tttt[2][2][2] = {111, 112, 121, 122, 211, 212, 221, 222};
 
    printf("buffer = %p, buffer[1] = %p\n", buffer, &buffer[1]);
 
    // 标识符究竟是什么？前几天听一个人说，标识符本质是代表内存地址，有名地址，相对于malloc的无名地址
    // 这很有趣，真的是这样吗？貌似有点道理，因为我们可以看到，标识符确实可以直接打印内存地址，跟 & 操作后的一样
    printf("pt = %p, pt' = %p\n", t, &t);
    printf("ptt = %p, ptt' = %p\n", tt, &tt);
    printf("pttt = %p, pttt' = %p\n", ttt, &ttt);
    printf("ptttt = %p, ptttt' = %p\n", tttt, &tttt);
 
    // 但我还是不明白，那么这个标识符代表的指针是什么类型呢？按照编译器的警告提示，foo 貌似代表 &foo[0]
    /** p1:按照上述猜想，tt 代表 &tt[0]
     *  第一个数字输出应当是 2
     *  &tt 类型 int(*)[8]，访问 &tt + 1时，越界，栈区内存从高到低，访问元素在tt[0]之上，有可能是在buffer区。
     *  由于对buffer做了特殊处理，我们知道是buffer[0]，-1
     *  这里说明一个问题。我本来预计，t的位置在buffer之下，那么buffer大小15，加一个t，刚好16。然而不是的，编译器把t的位置优化到tttt下面去了
     */
    printf("tt = %d, tt' = %d\n", *(tt + 1), *(int *)(&tt + 1));
    /** p2: ttt = &ttt[0], 指针类型 int(*)[4],
     *  ttt + 1指向跨度为4个int的第‘1’段，也就是 21，22，23，24，由于我们做了强制转换，应当是21
     *  &ttt 类型 int(*)[2][4]，这个访问方式越界了，溢出到tt的区域，tt[0], 1
     */
    printf("ttt = %d, ttt' = %d\n", *(int *)(ttt + 1), *(int *)(&ttt + 1));
    /** p3: tttt = &tttt[0], 指针类型 int(*)[2][2]
     *  tttt + 1 访问区域为 211, 212, 221, 222，强制转换后访问第0个元素，211
     *  &tttt 类型 int(*)[2][2][2]，大小上算是8个int，&tttt + 1后也是越界，访问区域在ttt中，强制转换后访问第0个元素，也就是11
     */
    printf("tttt = %d, tttt' = %d\n", *(int *)(tttt + 1), *(int *)(&tttt + 1));
 
    // 以上三个例子，打印结果是符合我的解释的。当然，我是根据打印结果来推测出这个结论的。再提一遍结论：标识符 foo 是个地址，指针类型是 &foo[0]
 
    // 再加一个函数指针的例子。看到很多书中，讲到函数指针时，赋值方式有带 & 的，有不带的。我一直不清楚什么区别。看来没区别
    printf("func = %p, func' = %p\n", testfunc, &testfunc);
	  return 0;
}
